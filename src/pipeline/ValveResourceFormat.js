import childProcess from 'child_process';
import debug from 'debug';
import fs from 'fs';
import path from 'path';

import { changeExtension } from './utils/index.js';

const CONVERSIONS = {
    '.vmdl': '.glb',
    '.vtex': '.png',
};
const ENCODINGS = {
    '.txt': 'utf8',
    '.vmat': 'utf8',
};

const log = debug( 'vrf:exec' );


/**
 * Integration layer with Valve's Source 2 resource parser and decompiler
 * See: https://github.com/SteamDatabase/ValveResourceFormat/
 */
class ValveResourceFormat {

    /**
     * 
     * @param {string} dotaDirVPKPath Dota 2 VPK 파일 ex) D:/Steam-Games/steamapps/common/dota 2 beta/game/dota/pak01_dir.vpk
     * @param {string} decompilerPath 추출용 실행 파일 ex) ./vrf/Decompiler.exe
     * @param {string} extractPath 추출된 파일 저장소 디렉토리 ex) ./extract
     */
    constructor( dotaDirVPKPath, decompilerPath, extractPath ) {

        /**
         * @type {string} pak01_dir.vpk 파일 전체 경로
         */
        this.dotaDirVPKPath = dotaDirVPKPath;
        /**
         * @type {string} Decompiler.exe 파일 경로
         */
        this.decompilerPath = decompilerPath;
        /**
         * @type {string} 추출 파일 저장 디렉토리 경로
         */
        this.extractPath = extractPath;
    }

    /**
     * Decompiler.exe 실행 옵션 헬퍼 메소드
     * @param {string[]} args 
     * @param {object} param1 
     * @returns 
     */
    execute( args, { maxBuffer = undefined } = {} ) {

        log( this.decompilerPath, ...args );

        // TODO: Async support
        const output = childProcess.execFileSync( this.decompilerPath, args, {
            encoding: 'utf8',
            maxBuffer,
        } );

        return output;
    }

    /**
     * 에셋 리소스 추출
     * @param {string} resource 에셋 파일 이름
     */
    extract( resource ) {

        this.execute( [
            '-i', this.dotaDirVPKPath,
            '-o', this.extractPath,
            '--gltf_export_materials',
            '--gltf_export_format', 'glb',
            '-d',
            '-f', resource,
        ] );
    }

    /**
     * 
     * @param {string} resource 에셋 파일 이름
     * @returns 
     */
    fetch( resource ) {

        const srcpath   = path.join( this.extractPath, resource );
        const extension = path.extname( srcpath );
        const outpath   = changeExtension( srcpath, CONVERSIONS[ extension ] );

        // TODO: Async support
        if ( !fs.existsSync( outpath ) ) {
            this.extract( resource );
        }

        const encoding = ENCODINGS[ extension ];
        return fs.readFileSync( outpath, {
            encoding
        } );
    }

    list( { extension = undefined } = {} ) {

        const extFilter = extension ? `-e ${extension}` : '';
        
        const source = this.execute( [ '-i', this.dotaDirVPKPath, '-l', extFilter ], {
            maxBuffer: Number.MAX_SAFE_INTEGER,
        } );

        // Exclude headers generated by VRF in output
        const list = source.trim().split( /\r?\n/ ).filter( ( entry ) => (
            !entry.startsWith( '---' ) && !entry.startsWith('[')
        ) );

        // Normalize to POSIX paths (required when running VRF on Windows)
        return list.map( ( entry ) => (
            entry.trim().split( path.sep ).join( path.posix.sep )
        ) );
    }

    get version() {

        return this.execute( [ '--version' ] ).trim();
    }
}

export default ValveResourceFormat;
